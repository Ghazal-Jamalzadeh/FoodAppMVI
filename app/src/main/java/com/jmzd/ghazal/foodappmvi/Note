نکته: اصل کلی:
توی state هایی که تعریف میکنیم حالت initial صفحه نباید هیچ وورودی ای داشته باشد
یعنی حتما باید آبجکت باشه
چون معمولا اون ورودی رو در وهله اول نداریم

چک کردن وضعیت اینترنت-------------------------------------------------------------------------------
توی معماری MVVM با استفاده از لایو دیتا یادگرفتیم وضعیت اینترنت رو چک کنیم
روشی که اینجا یاد میگیریم خیلی بهتر و بهینه تره
میخوایم لایو دیتا رو بذاریم کنار و کامل با فلو کار رو ببریم جلو

کلاس کانکتیویتی توی MVVM از لایو دیتا ارث بری میکرد.
توی MVI میخوایم از فلو استفاده کنیم
فلو یک متدی داره به اسم کالکت که تا حالا ده ها بار ازش استفاده کردیم
به این صورته که به ما این قابلیت رو میده که مدام از اون چیزه نپرسیم اتفاق افتاده یا نه
میگه یه بار منو به فلان چیز متصل کن هر بار که تغییراتی توی اون فلان چیز به وجود اومد من بلافاصله بهت میگم

پس نیاز به ییک فایلی دارم که در قالب فلو باشه
 و من بتونم آخرین وضعیت های مربوط به اینترنت رو استریم کنم روش

چطور اومدیم قبل تر کانال مربوط به کروتین رو تبدیل کردیم به فلو
 که راحت بفهمیم الان چه وضعیتی در حال اتفاق افتادن است
 و بعد با کالکت دسترسی پیدا کردیم به مقادیرش

برای هندل کردن این وضعیت ها از اینترفیس استفاده میکنیم
چرا اینترفیس؟
یک تعریف ساده اینترفیس اینه:
مثل یک پل ارتباطی میمونه بین چند تا چیز
به هم مرتبطشون میکنه که هر موقع این اتفاق افتاد این کارو کن...
در نهایت اینو در اختیار طرف دیگه کار میذاره
مثل یک شلنگ آب میمونه که دو تا سر داره
زمانی که شیر آب رو باز میکنیم اون سر دیگه شلنگ هر جا باشه آب از همونجا سرازیر میشه میاد بیرون
ما هم وقتی میایم یک سر اینترفیس رو به یک کلاسی وصل میکنیم اون سر دیگه ش هر جا باشه این اطلاعات در اختیارش قرار میگیره

#ConnectivityStatus interface
ما برای وضعیت های اینترنت ۴ تا وضعیت تعریف میکنیم
چرا چهار وضعیت؟
چون قبلا از این کلاس بارها استفاده کرده استاد و میدونه که این چهار وضعیت رو بهمون میده
ولی اگر ندونید: با خوندن کد هم میتونید متوجه شید
Available = اینترت وصله
Unavailable =
Losing =
Lost = کلا قطعه

از طرفی گفتیم نیاز به یک فلو داریم برای به این وضعیت ها به صورت استریم دسترسی پیدا کنیم

fun observe(): Flow<Status>
کلاس کانکتیویتی توی MVVM از لایو دیتا ارث بری میکرد.
توی MVI میخوایم از فلو استفاده کنیم پس از فلو ارث بری میکنیم
حالا میتونیم روش کالکت بزنیم
این فلو رو از نوع همین enum ی که تعریف کردیم در نظر میگیریم

# NetworkConnectivity class :
هم دیتا را در نظر میگیریم هم وای فای رو توی این کد:
اگه یادتون بیاد گفتیم زمانی که میخوایم از کانکتیویتی منیجر استفاده کنیم
 نیاز به یک کلاسی داریم که توش کانکتیویتی منیجر رو تعریف کنیم
و وابستگی هاشو تعریف کنیم و...

اولین بار توی فصل لایو دیتا اومدیم توی بلاک init constructor این رو initialize کردیم
کد قبلی و توضیح خط به خط کد از فصل لایو دیتا:
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/CheckConnection.kt
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/NetworkActivity.kt

بعد توی پروژه MVVM اومدیم وابستگیشو توی یک ماژول جدا تعریف کردیم و استفاده کردیم
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/di/OtherModule.kt
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/CheckConnection.kt
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/Note

گفتیم کلاس کانکتیویتی منیجر مربوط به خود اندرویده
که این وضعیت های مختلف کانکشن رو در اختیار من قرار میده
پس من نیاز دارم که از این استفاده کنم
حالا که نیاز دارم از این استفاده کنم پس باید یک جا تعریفش کنم

اگه نخوایم به صورت تامین وابستگی بنویسیم:
class NetworkConnectivity constructor(val context : Context){

val manager : ConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

  val request = NetworkRequest
        .Builder()
        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
        .build()
}

## ConnectivityManager :

val manager : ConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

چون نیاز به کانتکس داریم توی کانستراکتور میگیریم
بعد از طریق این کانتکس به سیستم سرویس دسترسی پیدا میکنیم
اون کانتکس دومی تو پرانتز کلاس کانتکسه. دقت کنید
توسط کلاس کاننتکس میام اون سرویسی که میخوام اجرا بشه رو دسترسی پیدا میکنم
در نهایت کستش میکنم

پس کلاس من به دو تا چیز وابسته شد
کانتکس و منیجر

چرا منیجر؟
چون این کلاس کانکتیویتی برای اینکه بفهمه اینترنت وصله یا نه به این نیاز داره
و این باید initialize شه

ولی گفتیم میخوایم حالت اینترنت دیتا رو هم متوجه شیم دیگه؟
پس یک وابستگی دیگه هم پیدا میکنیم اینجا

NetworkRequest :

که کدش به این شکل میشه بدون تزریق وابستگی:
  val request = NetworkRequest
        .Builder()
        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
        .build()

ما برای اینکه هر دو وضعیت وای فای و دیتا رو داشته باشیم از این نتورک ریکویست استفاده میکنیم
بعد از بیلدرش استفاده میکنیم برای دسترسی به حالت های مختلفش
یک متدی داره به اسم addTransportType :
ما باید اون چیزهای مختلف رو توی این بهش بدیم
وقتی NetworkCapabilities رو بزنیم انواع ظرفیت هایی که داره رو میاره
وای فای - دیتا - بلوتوث - usb - کابل - اترنت - ....
راه های ارتباطی مختلف
ما وای فای و دیتا رو میخوایم پس میاریمشون و در نهایت بیلدش میکنیم

پس ما دو تا وابستگی کانتکس و کانکتیویتی منیجر رو که توی پروژه های قبلی داشتیم
به نتورک ریکوعست هم وابستگی پیدا کردیم اینجا

ولی ما میخوایم با تزریق وابستگی کار کنیم->
کل این وابستگی ها رو میبریم توی ماژول other به صورت سینگل تون تعریف میکنیم

# implements
خب حالا وابستگی های این کلاس رو تامین کردیم
میایم از اون اینترفیسی که بالاتر تعریف کرده بودیم ارث بری میکنیم
که بعد باید متد observe رو override کنیم در نتیجه
خروجی این یک فلویی هست از اون enum هایی که تعریف کرده بودیم

### callbackFlow
پس میایم return میکنیم. چی رو؟ یک فلویی رو
از callbackFlow استفاده میکنیم که اون حالت ها رو در قالب کال بک داشته باشم
بتونم بفرستم به هر صفحه ای و ازش استفاده کنم

بعد میایم یک متغیری تعریف میکنیم به اسم کال بک
 val callback = object : ConnectivityManager.NetworkCallback() {

 }
 این خط کد چیکار میکنه؟
توسط این حالت های مختلفی از اینترنت رو داریم که میتونیم بگیم در صورت وقوع هر کدوم چه اتفاقی بی افته
دونه به دونه هر کدوم از حالت های اینترنت که نیاز داریم رو override میکنیم
که دقیقا میشه اون چهار تایی که داخل enum ها تعریف کردیم
که ما میایم داخل هر کدوم اون enum متناظرش رو روی فلو میفرستیم
با استفاده از متد send که قبلا آشنا شدیم
ولی چون ساسپند است باید یک اسکوپی چیزی بهش بدیم یا ساسپندش کنیم
خب ما داخل ففلو هستیم
خیلی راحت مینویسیم launch

send :
ما تا الان سند رو روی چنل های کروتین که استفاده میکردیم دیده بودیم
ما زمانی که از فلو استفاده میکنیم خود فلو از کروتین ساخته شده
پس ما میتونیم از اون کدهای داخلیشم استفاده کنیم


حالت های onAvailable & onLost مهم ترین ها هستن که ۱۰۰٪ به ما جواب میدن

### register & unRegister :
اگه از کدهای پروژه قبل یادتون باشه ما رجیستر و آن رجیستر میکردیم این کانکتیوتی منیجر رو
که این روش رجیستر کردن توی اندروید ۲۴ به بالا عوض میشه
که ما این رو توی کدمون اعمال میکنیم

برای آن رجیستر کردن میایم چیکار میکنیم؟
توی بلاک awaitClose کدشو میزنیم

### distinctUntilChanged :
در نهایت کال بکمون که تموم میشه بلاک کدش این متد رو صدا میزنیم
که در موردش قبلا توی فلو آموزش داده شده...

نحوه استفاده از کلاس کانکتیویتی در اکتیویتی----------------------------------------------------------
اول وابستگیشو تامین میکنیم
بعد متد آبزروش رو صدا میزنیم ( همونی که توی اینترفیس نوشتیم)
بعد چون خروجیش از جنس فلو بود کالکتش میکنیم
بعد چون کالکت ساسپند است بهش اسکوپی چیزی میدیم

پیشنهاد خودم:
چک کردن اینترنت باید داخل ویومدل چک شه...

گزارش باگ:
کد باگ زمان MVVM رو که اگه اینترنت قطع بود و اپ رو باز میکردیم کرش میکرد نداره
ولی اگه همچنان تو قطعی اینترنت api ی کال کنیم کرش رخ میده
چون فقط یک بار وصلی اینترنت رو زمان لانچ چک میکنیم
باید قبل کال کردن هر api به صورت مستقل چک شه...

یوتیوب پلیر-----------------------------------------------------------------------------------------
اگر خاطرتون باشه توی جلسات قبل گقتیم که این چیزی که داریم استفاده میکنیم
 در واقع یک بخشی از اپ یوتیوبه
  که میاد یک بخشی از اپ یوتیوب رو برای ما implement میکنه که ما بتونیم ازش استفاده کنیم
پس اگر اپلیکیشن یوتیو توی دستگاه ما وجود نداشته باشه
 عملا از این حالت نمیتونیم استفاده کنیم و برامون ارور میده
 ولی از اونجایی که اپلیکیشن یوتیوب به صورت پیش فرض روی ۹۹.۹۹٪ دستگاه ها نصبه
 اون یک درصدم دستگاه روت شده ان
 حتی دستگاه های هوواوی که تحریمن هم مشکلی ندارن از این جهت
  روی امولاتورها هم اکثرا نصبه
  وقتی از امولاتورهای متفرقه مثل ممو و ناکس استفاده میکنیم اکثرا ندارن یوتیوبب پلیر ندارن
  که خودمون باید نصب کنیم
  نصبشون هم کاری نداره
  روش اول نصب:
  میایم apk شو دانلود میکنیم با لپ تاپ
  بعد با drag & drop بندازیدش تو صفحه امولاتور
  ببعد میپرسه میخوای نصبش کنم؟ که میذاریم نصب کنه
  روش دوم نصب:
  با مرورگر خود امولاتور برید دانلود و نصب کنید

YouTubeBaseActivity---------------------------------------------------------------------------------
توی پلیر اکتیویتی
 از اونجایی که ما از اپ کامپت اکتیویتی ارث بری نکریم
 و از یک اکتیویتی دیگه ای ارث بری کردیم
 مهم نیست که حالا ما بیایم بیس درست کنیم یا نه
  سعی میکنیم توی پروژه های فصل چهار راجع به بیس ها هم توضیح بدیم و بیس اکتیویتی درست کنیم و...
به هر حال ما بیس اکتیویتی هم درست کنیم میایم از اپ کامپت اکتیویتی ارث بری میکنیم
حالا خود اپ کامپت اکتیویتی درسته از اکتیویتی و چیزای دیگه ارث بری میکنه
ولی به هر حال اومدن داخل خود اپ کامپت اکتیویتی
یک سری کدهای دیگه رو نوشتن که ما بتونیم راحت از ویومدل استفاده کنیم
ولی اگر وارد یوتیوب بیس اکتیویتی بشیم میبینیم از خود اکتیویتی ارث بری کرده
و خود اکتویتی ماسفانه اون کدهای مربوط به ویومدل رو نداره
خود اپ کامپت اکتیویتی از چیزهای زیادی ارث بری میکنه و نهایتا از اکتیویتی ارث بری میکنه
ولی این وسط owner های مختلفی داره
از جمله lifeCycleOwner & viewModelOwner که ازشون ارث بری میکنه
ولی چون یوتیوب پلیر اکتیویتی اینا رو نداره ما نمیتونیم داخلش از ویومدل و ... استفاده کنیم
فارغ از معماری میایم سنتی توش کد میزنیم
اصلا تکه کد by viewModels() رو نمیشناسه این اکتیویتی

روش های استفاده از ویومدل---------------------------------------------------------------------------
1- kotlin delegates :
که تا الان از همین روش استفاده کردیم
فوق العاده روش خوبیه
حتی به لایف سایکل آگاهه
بهترین روشه
private val viewModel: HomeViewModel by viewModels()

2- viewModelProvider
روش قدیمی تریه
باید خودمون owner ش رو بهش بدیم که آگاهی داشته  باشه به لایف سایکل
که از this استفاده میکنیم
که بعدشم باید یک سری کارهای دیگه انجام بدید که اکتیویتی بشناسدش
و این روش کاملا منسوخ و قدیمی شده
private val viewModel2 = ViewModelProvider(this)
اصلا بهینه نیس چون ما آگاهی کامل به لایف سایکل اون صفحه نداریم
private val viewModel2 = ViewModelProvider(this)[HomeViewModel ::class.java]


نکته ریلیز کردن یوتیوب پلیر-------------------------------------------------------------------------
کدی که ما زدیم میایم حتما توی onCreate یوتیوب پلیر رو initialize میکنیم
ولی گفتیم اگر اپ یوتیوب توی گوشی ما نصب نباشه این اتفاق نمی افته
پس میایم یک کدی میزنیم که قبل ریلیز کردن پلیر چک کنه اگه فقط اگه قبلا initialize شده ریلیزش کنه

این کد برای به حداقل رسوندن کرش های اپلیکیشن خیلی کاربردیه...
محدود به یوتیوب پلیر هم نیست

این lateinit میاد یک قابلیتی به ما میده که ما چک کنیم این initialize شده یا نه

مثلا بعضی وقتا که با دیالوگ کار میکنیم هم به این مشکل میخوریم
میخوایم بر اثر یک اکشنی ییک دیالوگ رو باز کنیم
و توسط یک اکشن دیگه همون دیالوگ رو بیایم ببندیم
یعنی باز و بسته شدن دیالوگ توس کد خودش اتفاق نمی افته و توسط اکشن های مختلفه
اگر از این روش استفاده نکنید و کاربر قل باز شدن دیالوگ اونو ببنده کرش میکنید

به هر دلیلی جایی از این lateinit استفاده کردیم باید این ملاحظات رو انجام بدیم
   if (this::player.isInitialized)
            player.release()

سوال:
چرا اگه کد رو به این شکل بنویسیم کار نمی کنه؟
   if (player.isInitialized)
جواب :
زمانی که میخوایم از isInitialized استفاده کنیم
یا از حالت های مختلف دیگه ای که برای ساخته شدن lateinit هست استفاده کنیم
باید دسترسی مستقیم داشته باشیم به instance اون
پس باید بیایم از دستور this استفاده کنیم
این this میاد به اون صفحه ای که ما داریم اشاره میکنه

نمونه کد برای مال دیالوگ هم داخل پلیر اکتیویتی قرار داده شده و کامنت شده ->
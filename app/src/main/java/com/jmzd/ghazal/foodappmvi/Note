نکته: اصل کلی:
توی state هایی که تعریف میکنیم حالت initial صفحه نباید هیچ وورودی ای داشته باشد
یعنی حتما باید آبجکت باشه
چون معمولا اون ورودی رو در وهله اول نداریم

چک کردن وضعیت اینترنت-------------------------------------------------------------------------------
توی معماری MVVM با استفاده از لایو دیتا یادگرفتیم وضعیت اینترنت رو چک کنیم
روشی که اینجا یاد میگیریم خیلی بهتر و بهینه تره
میخوایم لایو دیتا رو بذاریم کنار و کامل با فلو کار رو ببریم جلو

کلاس کانکتیویتی توی MVVM از لایو دیتا ارث بری میکرد.
توی MVI میخوایم از فلو استفاده کنیم
فلو یک متدی داره به اسم کالکت که تا حالا ده ها بار ازش استفاده کردیم
به این صورته که به ما این قابلیت رو میده که مدام از اون چیزه نپرسیم اتفاق افتاده یا نه
میگه یه بار منو به فلان چیز متصل کن هر بار که تغییراتی توی اون فلان چیز به وجود اومد من بلافاصله بهت میگم

پس نیاز به ییک فایلی دارم که در قالب فلو باشه
 و من بتونم آخرین وضعیت های مربوط به اینترنت رو استریم کنم روش

چطور اومدیم قبل تر کانال مربوط به کروتین رو تبدیل کردیم به فلو
 که راحت بفهمیم الان چه وضعیتی در حال اتفاق افتادن است
 و بعد با کالکت دسترسی پیدا کردیم به مقادیرش

برای هندل کردن این وضعیت ها از اینترفیس استفاده میکنیم
چرا اینترفیس؟
یک تعریف ساده اینترفیس اینه:
مثل یک پل ارتباطی میمونه بین چند تا چیز
به هم مرتبطشون میکنه که هر موقع این اتفاق افتاد این کارو کن...
در نهایت اینو در اختیار طرف دیگه کار میذاره
مثل یک شلنگ آب میمونه که دو تا سر داره
زمانی که شیر آب رو باز میکنیم اون سر دیگه شلنگ هر جا باشه آب از همونجا سرازیر میشه میاد بیرون
ما هم وقتی میایم یک سر اینترفیس رو به یک کلاسی وصل میکنیم اون سر دیگه ش هر جا باشه این اطلاعات در اختیارش قرار میگیره

#ConnectivityStatus interface
ما برای وضعیت های اینترنت ۴ تا وضعیت تعریف میکنیم
چرا چهار وضعیت؟
چون قبلا از این کلاس بارها استفاده کرده استاد و میدونه که این چهار وضعیت رو بهمون میده
ولی اگر ندونید: با خوندن کد هم میتونید متوجه شید
Available = اینترت وصله
Unavailable =
Losing =
Lost = کلا قطعه

از طرفی گفتیم نیاز به یک فلو داریم برای به این وضعیت ها به صورت استریم دسترسی پیدا کنیم

fun observe(): Flow<Status>
کلاس کانکتیویتی توی MVVM از لایو دیتا ارث بری میکرد.
توی MVI میخوایم از فلو استفاده کنیم پس از فلو ارث بری میکنیم
حالا میتونیم روش کالکت بزنیم
این فلو رو از نوع همین enum ی که تعریف کردیم در نظر میگیریم

# NetworkConnectivity class :
هم دیتا را در نظر میگیریم هم وای فای رو توی این کد:
اگه یادتون بیاد گفتیم زمانی که میخوایم از کانکتیویتی منیجر استفاده کنیم
 نیاز به یک کلاسی داریم که توش کانکتیویتی منیجر رو تعریف کنیم
و وابستگی هاشو تعریف کنیم و...

اولین بار توی فصل لایو دیتا اومدیم توی بلاک init constructor این رو initialize کردیم
کد قبلی و توضیح خط به خط کد از فصل لایو دیتا:
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/CheckConnection.kt
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/NetworkActivity.kt

بعد توی پروژه MVVM اومدیم وابستگیشو توی یک ماژول جدا تعریف کردیم و استفاده کردیم
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/di/OtherModule.kt
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/CheckConnection.kt
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/Note

گفتیم کلاس کانکتیویتی منیجر مربوط به خود اندرویده
که این وضعیت های مختلف کانکشن رو در اختیار من قرار میده
پس من نیاز دارم که از این استفاده کنم
حالا که نیاز دارم از این استفاده کنم پس باید یک جا تعریفش کنم

اگه نخوایم به صورت تامین وابستگی بنویسیم:
class NetworkConnectivity constructor(val context : Context){

val manager : ConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

  val request = NetworkRequest
        .Builder()
        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
        .build()
}

## ConnectivityManager :

val manager : ConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

چون نیاز به کانتکس داریم توی کانستراکتور میگیریم
بعد از طریق این کانتکس به سیستم سرویس دسترسی پیدا میکنیم
اون کانتکس دومی تو پرانتز کلاس کانتکسه. دقت کنید
توسط کلاس کاننتکس میام اون سرویسی که میخوام اجرا بشه رو دسترسی پیدا میکنم
در نهایت کستش میکنم

پس کلاس من به دو تا چیز وابسته شد
کانتکس و منیجر

چرا منیجر؟
چون این کلاس کانکتیویتی برای اینکه بفهمه اینترنت وصله یا نه به این نیاز داره
و این باید initialize شه

ولی گفتیم میخوایم حالت اینترنت دیتا رو هم متوجه شیم دیگه؟
پس یک وابستگی دیگه هم پیدا میکنیم اینجا

NetworkRequest :

که کدش به این شکل میشه بدون تزریق وابستگی:
  val request = NetworkRequest
        .Builder()
        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
        .build()

ما برای اینکه هر دو وضعیت وای فای و دیتا رو داشته باشیم از این نتورک ریکویست استفاده میکنیم
بعد از بیلدرش استفاده میکنیم برای دسترسی به حالت های مختلفش
یک متدی داره به اسم addTransportType :
ما باید اون چیزهای مختلف رو توی این بهش بدیم
وقتی NetworkCapabilities رو بزنیم انواع ظرفیت هایی که داره رو میاره
وای فای - دیتا - بلوتوث - usb - کابل - اترنت - ....
راه های ارتباطی مختلف
ما وای فای و دیتا رو میخوایم پس میاریمشون و در نهایت بیلدش میکنیم

پس ما دو تا وابستگی کانتکس و کانکتیویتی منیجر رو که توی پروژه های قبلی داشتیم
به نتورک ریکوعست هم وابستگی پیدا کردیم اینجا

ولی ما میخوایم با تزریق وابستگی کار کنیم->
کل این وابستگی ها رو میبریم توی ماژول other به صورت سینگل تون تعریف میکنیم

# implements
خب حالا وابستگی های این کلاس رو تامین کردیم
میایم از اون اینترفیسی که بالاتر تعریف کرده بودیم ارث بری میکنیم
که بعد باید متد observe رو override کنیم در نتیجه
خروجی این یک فلویی هست از اون enum هایی که تعریف کرده بودیم

### callbackFlow
پس میایم return میکنیم. چی رو؟ یک فلویی رو
از callbackFlow استفاده میکنیم که اون حالت ها رو در قالب کال بک داشته باشم
بتونم بفرستم به هر صفحه ای و ازش استفاده کنم

بعد میایم یک متغیری تعریف میکنیم به اسم کال بک
 val callback = object : ConnectivityManager.NetworkCallback() {

 }
 این خط کد چیکار میکنه؟
توسط این حالت های مختلفی از اینترنت رو داریم که میتونیم بگیم در صورت وقوع هر کدوم چه اتفاقی بی افته
دونه به دونه هر کدوم از حالت های اینترنت که نیاز داریم رو override میکنیم
که دقیقا میشه اون چهار تایی که داخل enum ها تعریف کردیم
که ما میایم داخل هر کدوم اون enum متناظرش رو روی فلو میفرستیم
با استفاده از متد send که قبلا آشنا شدیم
ولی چون ساسپند است باید یک اسکوپی چیزی بهش بدیم یا ساسپندش کنیم
خب ما داخل ففلو هستیم
خیلی راحت مینویسیم launch

send :
ما تا الان سند رو روی چنل های کروتین که استفاده میکردیم دیده بودیم
ما زمانی که از فلو استفاده میکنیم خود فلو از کروتین ساخته شده
پس ما میتونیم از اون کدهای داخلیشم استفاده کنیم


حالت های onAvailable & onLost مهم ترین ها هستن که ۱۰۰٪ به ما جواب میدن

### register & unRegister :
اگه از کدهای پروژه قبل یادتون باشه ما رجیستر و آن رجیستر میکردیم این کانکتیوتی منیجر رو
که این روش رجیستر کردن توی اندروید ۲۴ به بالا عوض میشه
که ما این رو توی کدمون اعمال میکنیم

برای آن رجیستر کردن میایم چیکار میکنیم؟
توی بلاک awaitClose کدشو میزنیم

### distinctUntilChanged :
در نهایت کال بکمون که تموم میشه بلاک کدش این متد رو صدا میزنیم
که در موردش قبلا توی فلو آموزش داده شده...

نحوه استفاده از کلاس کانکتیویتی در اکتیویتی----------------------------------------------------------
اول وابستگیشو تامین میکنیم
بعد متد آبزروش رو صدا میزنیم ( همونی که توی اینترفیس نوشتیم)
بعد چون خروجیش از جنس فلو بود کالکتش میکنیم
بعد چون کالکت ساسپند است بهش اسکوپی چیزی میدیم

پیشنهاد خودم:
چک کردن اینترنت باید داخل ویومدل چک شه...

گزارش باگ:
کد باگ زمان MVVM رو که اگه اینترنت قطع بود و اپ رو باز میکردیم کرش میکرد نداره
ولی اگه همچنان تو قطعی اینترنت api ی کال کنیم کرش رخ میده
چون فقط یک بار وصلی اینترنت رو زمان لانچ چک میکنیم
باید قبل کال کردن هر api به صورت مستقل چک شه...

